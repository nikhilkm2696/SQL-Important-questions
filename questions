Given a table of candidates and their skills, you're tasked with finding the candidates best suited for an open Data Science job. You want to find candidates who are proficient in Python, Tableau, and PostgreSQL.

Write a query to list the candidates who possess all of the required skills for the job. Sort the output by candidate ID in ascending order.

Assumption:

There are no duplicates in the candidates table.
candidates Table:
Column Name	Type
candidate_id	integer
skill	varchar
candidates Example Input:
candidate_id	skill
123	Python
123	Tableau
123	PostgreSQL
234	R
234	PowerBI
234	SQL Server
345	Python
345	Tableau
Example Output:
candidate_id
123
Explanation
Candidate 123 is displayed because they have Python, Tableau, and PostgreSQL skills. 345 isn't included in the output because they're missing one of the required skills: PostgreSQL.

The dataset you are querying against may have different input & output - this is just an example!

p.s. give the hints below a try if you're stuck and don't know where to start!

p.p.s if you find this problem too tricky, even after the hints, check out my 30-day SQL learning roadmap, which features my favorite free resources to learn SQL! After you strengthen your SQL foundations, I'm sure you'll be more than ready to tackle this question!



Solution
Candidates with a variety of skillsets have applied for this role, but we need candidates who know Python, Tableau, and PostgreSQL.

We'll start by using the IN operator to find candidates which have some of the required skills:

SELECT candidate_id
FROM candidates
WHERE skill IN ('Python', 'Tableau', 'PostgreSQL');
The output should look something like this: (Showing random 5 records)

candidate_id	skill
123	Python
123	Tableau
123	PostgreSQL
345	Python
345	Tableau
We can see from the output that these candidates possess at least one of the necessary skills, but keep in mind, the problem is asking for candidates who have ALL THREE of these skills, so we aren't done quite yet!

It's important to keep in mind that the candidates table does not contain any duplicates, so each combination of candidate and skill is a unique row. Therefore, a candidate should have exactly 3 rows for each of the necessary skills in order to be qualified for the job.

Now, we group the candidates table by candidate ID using the GROUP BY clause and count the number of skills for each group using the COUNT function.

Let's look at the total number of required skills for each candidate:

SELECT
  candidate_id,
  COUNT(skill) AS skill_count
FROM candidates
WHERE skill IN ('Python', 'Tableau', 'PostgreSQL')
GROUP BY candidate_id;
Output:

candidate_id	skill_count
123	3
345	2
Candidate 123 possesses all three of the required skills in this instance, but Candidate 345 possesses only two of the required skills.

In the last step, we'll use HAVING to select only candidates with three skills and ORDER BY the candidate ID, as per the task.

Note that the full solution below counts skills inside the HAVING, not in the SELECT as shown above.

Full Solution:

SELECT candidate_id
FROM candidates
WHERE skill IN ('Python', 'Tableau', 'PostgreSQL')
GROUP BY candidate_id
HAVING COUNT(skill) = 3
ORDER BY candidate_id;

other solution:
select candidate_id from (select candidate_id,Count(candidate_id) from 
(select candidate_id from candidates where skill in ('Python','Tableau','PostgreSQL')) as a

group by candidate_id) as c where count=3 order by candidate_id




2)
Assume you are given the tables below about Facebook pages and page likes. Write a query to return the page IDs of all the Facebook pages that don't have any likes. The output should be in ascending order.

pages Table:
Column Name	Type
page_id	integer
page_name	varchar
pages Example Input:
page_id	page_name
20001	SQL Solutions
20045	Brain Exercises
20701	Tips for Data Analysts
page_likes Table:
Column Name	Type
user_id	integer
page_id	integer
liked_date	datetime
page_likes Example Input:
user_id	page_id	liked_date
111	20001	04/08/2022 00:00:00
121	20045	03/12/2022 00:00:00
156	20001	07/25/2022 00:00:00
Example Output:
page_id
20701
Explanation: The page with ID 20701 has no likes.

The dataset you are querying against may have different input & output - this is just an example!

SOLUTION:There are two ways to go about it. Either LEFT JOIN or RIGHT JOIN can be established between tables pages and page_likes or a subquery can be used to identify which pages have not been liked by any user.

The LEFT JOIN clause starts selecting data from the left table. For each row in the left table (pages), it compares the value in the page_id column with the value of each row in the page_id column in the right table (page_likes).

When page_id are found on both sides, the LEFT JOIN clause creates a new row that contains columns that appear in the SELECT clause and adds this row to the result set.

In case page_id frompages table is not available in page_likes table, the LEFT JOIN clause also creates a new row that contains columns that appear in the SELECT clause. In addition, it fills the columns that come from the page_likes (right table) with NULL. Rows having NULL values in the result is the set of the solution.

Read about LEFT JOIN [1] and RIGHT JOIN [2] to get the better understanding.

Solution #1: Using LEFT OUTER JOIN

SELECT pages.page_id
FROM pages
LEFT OUTER JOIN page_likes AS likes
  ON pages.page_id = likes.page_id
WHERE likes.page_id IS NULL;
Another solution to this problem, since pages with NO LIKES are needed, would be the NOT EXISTS clause (refer to Solution #2). It's an appropriate and efficient operator to get this information. Check out here.

Both methods give the same output.

Solution #2: Using NOT EXISTS

SELECT page_id
FROM pages
WHERE NOT EXISTS (
  SELECT 1
  FROM page_likes AS likes
  WHERE likes.page_id = pages.page_id);
Solution #3: Using EXCEPT

SELECT page_id
FROM pages
EXCEPT
SELECT page_id
FROM page_likes
ORDER BY page_id;


my-solution:::::::::


SELECT page_id from pages
where page_id not in (select distinct(page_id) from page_likes)
order by page_id ASC




3)Tesla is investigating bottlenecks in their production, and they need your help to extract the relevant data. Write a query that determines which parts have begun the assembly process but are not yet finished.

Assumptions

Table parts_assembly contains all parts in production.
A part with no finish_date is an unfinished part.
parts_assembly Table
Column Name	Type
part	string
finish_date	datetime
assembly_step	integer
parts_assembly Example Input
part	finish_date	assembly_step
battery	01/22/2022 00:00:00	1
battery	02/22/2022 00:00:00	2
battery	03/22/2022 00:00:00	3
bumper	01/22/2022 00:00:00	1
bumper	02/22/2022 00:00:00	2
bumper		3
bumper		4
Example Output
part
bumper
Explanation
The only item in the output is "bumper" because step 3 didn't have a finish date.

The dataset you are querying against may have different input & output - this is just an example!



Solution
The parts table already contains all of the parts that are currently in production, meaning that we do not have to do any additional filtering for the parts that are not in production.

All we need to do is extract the parts that are not yet finished. We can accomplish this by filtering for rows with no data present in the finish_date column. We call these missing values NULL.

Some parts might be represented multiple times in the query data because they have several assembly steps that are not yet complete. To solve this, we can group part or apply DISTINCT function to obtain the unique parts.

SELECT part
FROM parts_assembly
WHERE finish_date IS NULL
GROUP BY part;
OR

SELECT DISTINCT part
FROM parts_assembly
WHERE finish_date IS NULL;


mysolution:SELECT DISTINCT(part) FROM parts_assembly where finish_date is NULL;


4)MEDIUM:
This is the same question as problem #11 in the SQL Chapter of Ace the Data Science Interview!

Assume you are given the table below on Uber transactions made by users. Write a query to obtain the third transaction of every user. Output the user id, spend and transaction date.

transactions Table:
Column Name	Type
user_id	integer
spend	decimal
transaction_date	timestamp
transactions Example Input:
user_id	spend	transaction_date
111	100.50	01/08/2022 12:00:00
111	55.00	01/10/2022 12:00:00
121	36.00	01/18/2022 12:00:00
145	24.99	01/26/2022 12:00:00
111	89.60	02/05/2022 12:00:00
Example Output:
user_id	spend	transaction_date
111	89.60	02/05/2022 12:00:00
The dataset you are querying against may have different input & output - this is just an example!

Hint #1

Let's first figure out how we can order the users' transactions with a ranking system by assigning each transaction with a rank which we will need to use later. Do you think we can make use of a window function?

A little tip for you, it's called RANK function.

Check out here to learn about this window function.

MYSOLUTION:select user_id,spend,transaction_date from (select user_id,spend,transaction_date ,
RANK() OVER(PARTITION BY user_id ORDER BY transaction_date ) RANKY
FROM transactions ) as p where ranky=3


Solution
First, we obtain the order of transaction numbers for each user. We can do this by using the ROW_NUMBER window function where we PARTITION the all transactions by user_id and ORDER BY the transaction_date.

SELECT 
  user_id, 
  spend, 
  transaction_date, 
  ROW_NUMBER() OVER (
    PARTITION BY user_id ORDER BY transaction_date) AS row_num
FROM transactions;
Here's how the first 5 rows of output looks like:

user_id	spend	transaction_date	row_num
111	100.50	01/08/2022 12:00:00	1
111	55.00	01/10/2022 12:00:00	2
111	89.60	02/05/2022 12:00:00	3
121	36.00	01/18/2022 12:00:00	1
121	22.20	04/01/2022 12:00:00	2
From there on, we can simply convert the query into a subquery and filter for the users' third transaction which is their third transaction sorted by the transaction date (and is denoted as row_num = 3).

SELECT 
  user_id, 
  spend, 
  transaction_date
FROM (
  -- Insert the above query here 
) AS trans_num 
WHERE row_num = 3;
Results:

user_id	spend	transaction_date
111	89.60	02/05/2022 12:00:00
121	67.90	04/03/2022 12:00:00
Apart from using subquery to solve this question, you can also use a CTE. Do you know the differences between a subquery and a CTE?

A CTE is a temporary data set to be used as part of a query and it exists during the entire query session. A subquery is a nested query. It’s a query within a query and unlike CTE, it can be used within that query only. Read here and here for more understanding.

Both methods give the same output and perform fairly similarly. Differences are CTE is reusable during the entire session and more readable, whereas subquery can be used in FROM and WHERE clauses and can act as a column with a single value. We share more resources here (1, 2, 3) on their use cases.

Solution #1: Using Subquery

SELECT 
  user_id,
  spend,
  transaction_date
FROM (
  SELECT 
    user_id, 
    spend, 
    transaction_date, 
    ROW_NUMBER() OVER (
      PARTITION BY user_id ORDER BY transaction_date) AS row_num
  FROM transactions) AS trans_num 
WHERE row_num = 3;
Solution #2: Using CTE

WITH trans_num AS (
  SELECT 
    user_id, 
    spend, 
    transaction_date, 
    ROW_NUMBER() OVER (
      PARTITION BY user_id ORDER BY transaction_date) AS row_num 
  FROM transactions)
 
SELECT 
  user_id, 
  spend, 
  transaction_date 
FROM trans_num 
WHERE row_num = 3;


5)This is the same question as problem #3 in the SQL Chapter of Ace the Data Science Interview!

Assume that you are given the table below containing information on viewership by device type (where the three types are laptop, tablet, and phone). Define “mobile” as the sum of tablet and phone viewership numbers. Write a query to compare the viewership on laptops versus mobile devices.

Output the total viewership for laptop and mobile devices in the format of "laptop_views" and "mobile_views".

viewership Table:
Column Name	Type
user_id	integer
device_type	string ('laptop', 'tablet', 'phone')
view_time	timestamp
viewership Example Input:
user_id	device_type	view_time
123	tablet	01/02/2022 00:00:00
125	laptop	01/07/2022 00:00:00
128	laptop	02/09/2022 00:00:00
129	phone	02/09/2022 00:00:00
145	tablet	02/24/2022 00:00:00
Example Output:
laptop_views	mobile_views
2	3
Explanation: Given the example input, there are 2 laptop views and 3 mobile views.

The dataset you are querying against may have different input & output - this is just an example!

Hint #1

Try using a CASE statement to group laptop views into laptop_views column and tablet & phone views into mobile_views.

SELECT 
  CASE WHEN _____ = '_____' THEN 1 ELSE 0 END AS laptop_views, 
  CASE WHEN _____ IN ('_____', '_____') THEN 1 ELSE 0 END AS mobile_views 
FROM viewership;


SOLUTION:Solution
To compare the viewership on laptops versus mobile devices, we can use a CASE conditional statement to define the device type according to the question's specifications.

The tablet and phone categories are considered to be the 'mobile' device type and the laptop can be set as its own device type (i.e., 'laptop').

SELECT 
  CASE WHEN device_type = 'laptop' THEN 1 ELSE 0 END AS laptop_views, 
  CASE WHEN device_type IN ('tablet', 'phone') THEN 1 ELSE 0 END AS mobile_views 
FROM viewership;
laptop_views	mobile_views
0	1
1	0
1	0
0	1
0	1
Let us explain how the CASE statement works using the mobile_views field as an example.

When the device is a tablet or a phone, it is assigned the value of 1. Otherwise, it is given the value of 0.
The IN operator after device_type means OR, as in when the device type is a table OR phone, then it is assigned the value of 1.
Next, we calculate the number of viewership for laptops and mobiles. We can do so by applying the SUM function.

Solution:

SELECT 
  SUM(CASE WHEN device_type = 'laptop' THEN 1 ELSE 0 END) AS laptop_views, 
  SUM(CASE WHEN device_type IN ('tablet', 'phone') THEN 1 ELSE 0 END) AS mobile_views 
FROM viewership;
laptop_views	mobile_views
2	3
Ok, timeout guys!

We want you to take a step back and ask yourself this "Why can't you use the COUNT function instead since we're essentially "counting" the number of viewership?"

Say, we apply the COUNT function to the solution instead.

Run this query and we'll explain why it will give you the wrong output.

-- Incorrect solution
SELECT 
  COUNT(CASE WHEN device_type = 'laptop' THEN 1 ELSE 0 END) AS laptop_views, 
  COUNT(CASE WHEN device_type IN ('tablet', 'phone') THEN 1 ELSE 0 END) AS mobile_views 
FROM viewership;
Instead of adding the values of 1 and 0, using COUNT will count the number of rows instead which gives you the following output of 5 laptop views and 5 mobile views. That's counterintuitive!

laptop_views	mobile_views
5	5
There's another way that you can use the COUNT function and obtain the correct output. Since COUNT is counting the number of values in the rows, what you can do is switch out the value of 0 with NULL instead.

-- Another correct solution
SELECT 
  COUNT(CASE WHEN device_type = 'laptop' THEN 1 ELSE NULL END) AS laptop_views, 
  COUNT(CASE WHEN device_type IN ('tablet', 'phone') THEN 1 ELSE NULL END) AS mobile_views 
FROM viewership;
With this query, only the correctly assigned device type gets the value of 1.

COUNT and SUM are two very important functions and are frequently asked in technical interviews. We hope that with this question, you'll know how to apply them appropriately.

select sum(laptop_views) as laptop_views,sum(mobile_views) as mobile_views from (select 
case when device_type='laptop' then 1 else 0 end as laptop_views,
case when device_type in ('phone','tablet') then 1 else 0 end as mobile_views
from viewership) as p;



6)This is the same question as problem #8 in the SQL Chapter of Ace the Data Science Interview!

Assume you are given the table below that shows job postings for all companies on the LinkedIn platform. Write a query to get the number of companies that have posted duplicate job listings.

Clarification:

Duplicate job listings refer to two jobs at the same company with the same title and description.
job_listings Table:
Column Name	Type
job_id	integer
company_id	integer
title	string
description	string
job_listings Example Input:
job_id	company_id	title	description
248	827	Business Analyst	Business analyst evaluates past and current business data with the primary goal of improving decision-making processes within organizations.
149	845	Business Analyst	Business analyst evaluates past and current business data with the primary goal of improving decision-making processes within organizations.
945	345	Data Analyst	Data analyst reviews data to identify key insights into a business's customers and ways the data can be used to solve problems.
164	345	Data Analyst	Data analyst reviews data to identify key insights into a business's customers and ways the data can be used to solve problems.
172	244	Data Engineer	Data engineer works in a variety of settings to build systems that collect, manage, and convert raw data into usable information for data scientists and business analysts to interpret.
Example Output:
co_w_duplicate_jobs
1
Explanation
Because job IDs 945 and 164 are at the same company (345), and the jobs have the same title and description, there is exactly one company with a duplicate job.

The dataset you are querying against may have different input & output - this is just an example!



Solution
The first step to solving this LinkedIn question correctly is connecting with me on LinkedIn 🥺

But seriously, the first step is to find all the companies with job listings that has the same title and description. We can do that by COUNTing the number of job_ids grouped by company_id, title and description.

SELECT 
  company_id, 
  title, 
  description, 
  COUNT(job_id) AS job_count
FROM job_listings
GROUP BY 
  company_id, 
  title, 
  description;
Output (showing first 5 rows with total of 7 rows):

company_id	title	description	job_count
827	Data Scientist	Data scientist uses data to understand and explain the phenomena around them, and help organizations make better decisions.	2
244	Data Engineer	Data engineer works in a variety of settings to build systems that collect, manage, and convert raw data into usable information for data scientists and business analysts to interpret.	1
845	Business Analyst	Business analyst evaluates past and current business data with the primary goal of improving decision-making processes within organizations.	1
244	Software Engineer	Software engineers design and create computer systems and applications to solve real-world problems.	2
345	Data Analyst	Data analyst reviews data to identify key insights into a business's customers and ways the data can be used to solve problems.	2
Next, we convert the previous query into a CTE and filter for when job_count is more than 1 meaning we only want where there are 2 or more duplicate job listings. Then, we apply a DISTINCT on company_id to get the unique company_id and count them.

WITH jobs_grouped AS (
-- Insert above query here
)

SELECT COUNT(DISTINCT company_id) AS co_w_duplicate_jobs
FROM jobs_grouped
WHERE job_count > 1;
Results:

co_w_duplicate_jobs
3
Solution #1: Using CTE

WITH jobs_grouped AS (
  SELECT 
    company_id, 
    title, 
    description, 
    COUNT(job_id) AS job_count
  FROM job_listings
  GROUP BY 
    company_id, 
    title, 
    description)

SELECT COUNT(DISTINCT company_id) AS co_w_duplicate_jobs
FROM jobs_grouped
WHERE job_count > 1;
Solution #2: Using Subquery

SELECT COUNT(DISTINCT company_id) AS co_w_duplicate_jobs
FROM (
  SELECT 
    company_id, 
    title, 
    description, 
    COUNT(job_id) AS job_count
  FROM job_listings
  GROUP BY 
    company_id, 
    title, 
    description) AS jobs_grouped
WHERE job_count > 1;


select count(c) as co_w_duplicate_jobs from
(SELECT COUNT(company_id) as c FROM job_listings 
group by company_id,title,description) as p
where c>1;



7)Given a table of Facebook posts, for each user who posted at least twice in 2021, write a query to find the number of days between each user’s first post of the year and last post of the year in the year 2021. Output the user and number of the days between each user's first and last post.

p.s. If you've read the Ace the Data Science Interview and liked it, consider writing us a review?

posts Table:
Column Name	Type
user_id	integer
post_id	integer
post_date	timestamp
post_content	text
posts Example Input:
user_id	post_id	post_date	post_content
151652	599415	07/10/2021 12:00:00	Need a hug
661093	624356	07/29/2021 13:00:00	Bed. Class 8-12. Work 12-3. Gym 3-5 or 6. Then class 6-10. Another day that's gonna fly by. I miss my girlfriend
004239	784254	07/04/2021 11:00:00	Happy 4th of July!
661093	442560	07/08/2021 14:00:00	Just going to cry myself to sleep after watching Marley and Me.
151652	111766	07/12/2021 19:00:00	I'm so done with covid - need travelling ASAP!
Example Output:
user_id	days_between
151652	2
661093	21


Solution
First, we can use MIN and MAX clauses on the post_date column to retrieve the dates for the first and the last post, and then substract one from another accordingly.

As we are asked to find the difference on a user basis for the year 2021, it is important to GROUP the results by user_id, and then filter for the year 2021. To do so, we can use date_part function, which - as the name suggests - retrieves a part from input date. Thus, in our scenario it is the post_date variable. For more use cases, read more here.

Lastly, to filter out the users who have only posted once during the year, we can use HAVING clause with the COUNT of posts over 1

SELECT 
	user_id, 
    MAX(post_date::DATE) - MIN(post_date::DATE) AS days_between
FROM posts
WHERE DATE_PART('year', post_date::DATE) = 2021 
GROUP BY user_id
HAVING COUNT(post_id)>1;

mysolution:select user_id,
date_part('day',MAX(post_date)::timestamp-MIN(post_date)::timestamp) 
AS days_between
from posts where
EXTRACT('year' from post_date)='2021'
group by user_id
having count(user_id)>1  





8)
Write a query to find the top 2 power users who sent the most messages on Microsoft Teams in August 2022. Display the IDs of these 2 users along with the total number of messages they sent. Output the results in descending count of the messages.

Assumption:

No two users has sent the same number of messages in August 2022.
messages Table:
Column Name	Type
message_id	integer
sender_id	integer
receiver_id	integer
content	varchar
sent_date	datetime
messages Example Input:
message_id	sender_id	receiver_id	content	sent_date
901	3601	4500	You up?	08/03/2022 00:00:00
902	4500	3601	Only if you're buying	08/03/2022 00:00:00
743	3601	8752	Let's take this offline	06/14/2022 00:00:00
922	3601	4500	Get on the call	08/10/2022 00:00:00
Example Output:
sender_id	message_count
3601	2
4500	1
The dataset you are querying against may have different input & output - this is just an example!

Hint #1

Let's take one step at a time.

First, we must ensure that all the messages are sent in August 2022. We can pull the month and year information using the EXTRACT function using the sent_date field in the messages table.

SELECT sender_id, message_id
FROM messages
WHERE EXTRACT(MONTH FROM sent_date) = '8'
  AND EXTRACT(YEAR FROM sent_date) = '2022';
Can you use the COUNT function together with the GROUP BY clause to determine how many messages were sent by each user?



Solution
Before we can find the top 2 Microsoft Teams power users, we need to know how many messages were sent by each Microsoft Teams user in August 2022. We will refer to these users as "senders".

First, we extract the month and year from the sent_date field. Then, we count the messages for each sender and group them based on the sender_id:

SELECT 
  sender_id,
  COUNT(message_id) AS count_messages
FROM messages
WHERE EXTRACT(MONTH FROM sent_date) = '8'
  AND EXTRACT(YEAR FROM sent_date) = '2022'
GROUP BY sender_id;
Here over here to learn more about the EXTRACT function, and here to learn about the GROUP BY clause.

The output from the above query should look something like this:

sender_id	count_messages
2520	3
3601	4
4500	1
Because we're operating under the assumption that no two users can send the same number of messages in August 2022, we know that each number in the count_messages column will only appear once. That means that a simple ORDER BY clause in descending order will give us the result we need. We then use a LIMIT clause to pull only the top 2 results, and we're done!

Solution:

SELECT 
  sender_id,
  COUNT(message_id) AS count_messages
FROM messages
WHERE EXTRACT(MONTH FROM sent_date) = '8'
  AND EXTRACT(YEAR FROM sent_date) = '2022'
GROUP BY sender_id
ORDER BY count_messages DESC
LIMIT 2; 



mysolution:SELECT sender_id,count(sender_id) as message_count FROM messages
where extract(MONTH FROM sent_date)='8' and extract(YEAR FROM sent_date)='2022'
group by sender_id
order by message_count desc limit 2;


9)
Easy

Amazon
Given the reviews table, write a query to get the average stars for each product every month.

The output should include the month in numerical value, product id, and average star rating rounded to two decimal places. Sort the output based on month followed by the product id.

P.S. If you've read the Ace the Data Science Interview, and liked it, consider writing us a review?

reviews Table:
Column Name	Type
review_id	integer
user_id	integer
submit_date	datetime
product_id	integer
stars	integer (1-5)
reviews Example Input:
review_id	user_id	submit_date	product_id	stars
6171	123	06/08/2022 00:00:00	50001	4
7802	265	06/10/2022 00:00:00	69852	4
5293	362	06/18/2022 00:00:00	50001	3
6352	192	07/26/2022 00:00:00	69852	3
4517	981	07/05/2022 00:00:00	69852	2
Example Output:
mth	product	avg_stars
6	50001	3.50
6	69852	4.00
7	69852	2.50
Explanation
In June (month #6), product 50001 had two ratings - 4 and 3, resulting in an average star rating of 3.5.

The dataset you are querying against may have different input & output - this is just an example!

Want to try other Amazon SQL Interview Questions?
Here's some more Amazon SQL Interview Questions:Amazon SQL Interview Questions

Hint #1

Let's take the first step. The question is asking for the month in the output, but we do not see any month column in the reviews table. So, how do we get this column?

If you're thinking of extracting it from the submit_date column, then you're on the right path! The EXTRACT function will help us out here.

Your code snippet should look similar to this:

SELECT EXTRACT(MONTH FROM submit_date) AS mth
FROM reviews;




Solution
As we can see, there is no month column in the reviews table. First, we have to extract the month from the submit_date column.

There is a simple function to extract month from a date. Here's the syntax: EXTRACT(MONTH from column_name)

You can look at this page for more explanation on the EXTRACT function.

After extracting the month in numerical values, get the average of the star ratings and round them to two decimal places. It can be achieved using the functions AVG() and ROUND(). Please refer [1] & [2] for some reading on the functions.

Solution:

SELECT 
  EXTRACT(MONTH FROM submit_date) AS mth,
  product_id,
  ROUND(AVG(stars), 2) AS avg_stars
FROM reviews
GROUP BY EXTRACT(MONTH FROM submit_date), product_id
ORDER BY mth, product_id;
Why can't we write mth in the GROUP BY clause, but we can do so in the ORDER BY clause?

This is the order of sequence of how SQL executes the solution's query from top to bottom:

1 - FROM reviews
2 - GROUP BY EXTRACT(MONTH FROM submit_date) ...
3 - SELECT EXTRACT(MONTH FROM submit_date) AS mth ...
4 - ORDER BY mth ...
SQL runs the GROUP BY clause BEFORE the SELECT statement. Hence, when SQL executes the grouping, it cannot say GROUP BY mth because the mth column only exists AFTER the SELECT statement is executed.

The reason why we can execute mth column in the ORDER BY clause is because it's run after the SELECT statement and mth column has been created.

This is a very popular question in technical interviews so make sure that you learn the order of SQL execution well!



mysolution:


SELECT EXTRACT(MONTH FROM submit_date) as mth,product_id as product,
ROUND((SUM(stars)::decimal/COUNT(product_id))::NUMERIC,2) as avg_stars FROM reviews
group by product_id,EXTRACT(MONTH FROM submit_date)
order by mth ,product_id;
